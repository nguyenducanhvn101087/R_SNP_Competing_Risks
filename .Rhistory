abline(h = 377, col='black', lty=2, lwd=1)
abline(h = 700, col='black', lty=2, lwd=1)
legend(150, 300, bty='n', lty=c(3,1), lwd=c(2,2), col=c('red', 'blue'), legend=c('LFUP', 'DFS'))
aocs <- anim.lines(ts, cs, col='red', lwd=2, lty=3, window=1:t, speed=40)
80-48
32/20
204*.9
184*1.1
204/1.1
186*1.1
n <- 204/2 / 1.1
n
n*2
n*2*1.1
power.prop.test(n, p1, p2)
p1 <- .48
p2 <- .8
prev <- .6
p1 <- .48
p2 <- .8
power.prop.test(n*prev, p1, p2)
power.prop.test(n*prev, p1, p2)$pow
prev <- .5
p1 <- .48
p2 <- .8
power.prop.test(n*prev, p1, p2)$pow
require(numDeriv)
x0 <- rnorm(100)
exact <- sc2.g(x0)
g <- grad(func=sc2.f, x=x0)
max(abs(exact - g)/(1 + abs(exact)))
gc <- grad(func=sc2.f, x=x0, method="complex")
max(abs(exact - gc)/(1 + abs(exact)))
f <- function(x) if(x[1]<=0) sum(sin(x)) else NA
grad(f, x=c(0,0), method="Richardson", side=c(-1, 1))
sc2.g <- function(x){
n <- length(x)
(1:n) * (exp(x) - 1) / n
}
x0 <- rnorm(100)
exact <- sc2.g(x0)
g <- grad(func=sc2.f, x=x0)
max(abs(exact - g)/(1 + abs(exact)))
gc <- grad(func=sc2.f, x=x0, method="complex")
max(abs(exact - gc)/(1 + abs(exact)))
f <- function(x) if(x[1]<=0) sum(sin(x)) else NA
grad(f, x=c(0,0), method="Richardson", side=c(-1, 1))
sc2.f <- function(x){
n <- length(x)
sum((1:n) * (exp(x) - x)) / n
}
x0 <- rnorm(100)
exact <- sc2.g(x0)
g <- grad(func=sc2.f, x=x0)
max(abs(exact - g)/(1 + abs(exact)))
gc <- grad(func=sc2.f, x=x0, method="complex")
max(abs(exact - gc)/(1 + abs(exact)))
f <- function(x) if(x[1]<=0) sum(sin(x)) else NA
grad(f, x=c(0,0), method="Richardson", side=c(-1, 1))
system.time(grad(func=sc2.f, x=x0))
system.time(jacobian(func=sc2.f, x=x0))
x0 <- rnorm(1e6)
system.time(jacobian(func=sc2.f, x=x0))
system.time(grad(func=sc2.f, x=x0))
x0 <- rnorm(1e3)
system.time(grad(func=sc2.f, x=x0))
system.time(jacobian(func=sc2.f, x=x0))
18*4
18*4+4*36
18+36+54
18+36+54+66
36*4
18+36+54
18+36+54+33
18+36+54+66
pbinom(q = 2, prob = .5, size = 9)
?pbinom
pbinom(q = 2, prob = .5, size = 18)
pbinom(q = 4, prob = .5, size = 18)
pbinom(q = 4, prob = .5, size = 18, lower.tail = T)
pbinom(q = 18, prob = .5, size = 700, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 700, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 50, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 30, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 40, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 45, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 42, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 44, lower.tail = T)
1-pbinom(q = 18, prob = .5, size = 43, lower.tail = T)
1-pbinom(q = 14, prob = .5, size = 43, lower.tail = T)
1-pbinom(q = 13, prob = .5, size = 43, lower.tail = T)
1-pbinom(q = 13, prob = .5, size = 42, lower.tail = T)
1-pbinom(q = 13, prob = .5, size = 41, lower.tail = T)
1-pbinom(q = 13, prob = .5, size = 40, lower.tail = T)
1/.4
arms <- sample(c('a', 'b'), size = n, replace = T, prob = .5)
set.seed(69)
lat.haz1a <- .8
lat.hr1 <- .5
lat.haz2a <- .8
lat.hr2 <- .7
n <- 500
arms <- sample(c('a', 'b'), size = n, replace = T, prob = .5)
arms <- sample(c('a', 'b'), size = n, replace = T, prob = rep(.5,2))
arms
lat.t1 <- lat.t2 <- rep(NA, n)
lat.t1 <- lat.t2 <- rep(NA, n)
lat.t1[arms=='a'] <- rexp(sum(arms=='a'), rate=lat.haz1a)
lat.t1[arms=='b'] <- rexp(sum(arms=='b'), rate=lat.haz1a * lat.hr1)
lat.t2[arms=='a'] <- rexp(sum(arms=='a'), rate=lat.haz2a)
lat.t2[arms=='b'] <- rexp(sum(arms=='b'), rate=lat.haz2a * lat.hr2)
lat.t1
times <- ifelse(lat.t1 <= lat.t2, lat.t1, lat.t2)
status<- ifelse(lat.t1 <= lat.t2, 1, 2)
dat <- data.frame(time, status, arms)
status<- ifelse(lat.t1 <= lat.t2, 1, 2)
dat <- data.frame(time, status, arms)
dat <- data.frame(times, status, arms)
head(dat)
require(cmp)
require(cmprsk)
require(riskRegression)
install.packages(riskRegression)
source('C:/Google Drive/0_frmDropbox/2_SNPCIFEst/SNPCIFEst_Paper/OriginalSNPcodes/2_snpcr.uti.r')
setwd("C:/GitHub/SNP_CR_R/R_SNP_Competing_Risks")
install.packages("C:/GitHub/SNP_CR_R/R_SNP_Competing_Risks/MyRcpp_1.0.tar.gz", repos = NULL, type = "source")
.libPaths()
setwd("C:/GitHub/SNP_CR_R/R_SNP_Competing_Risks")
library("MyRcpp", lib.loc="C:/R/R-3.3.2/library")
detach("package:MyRcpp", unload=TRUE)
require(cmprsk)
require(eha)
require(parallel)
# require(BB)
# require(Rcgmin)
# require(rgenoud)
require(methods)
require(maxLik)
require(MLEcens)
require(Matrix)
require(matrixcalc)
require(varComp)
require(prodlim)
require(MyRcpp)
install.packages('maxLik')
require(cmprsk)
require(eha)
require(parallel)
# require(BB)
# require(Rcgmin)
# require(rgenoud)
require(methods)
require(maxLik)
require(MLEcens)
require(Matrix)
require(matrixcalc)
require(varComp)
require(prodlim)
require(MyRcpp)
rm(list = ls())
source("1_snpcr.r")
install.packages(c('Rlab', 'polynom'))
source("1_snpcr.r")
graphics.off()
dat <- read.csv('cleardeath.csv', )
head(dat)
dat <- read.csv('cleardeath.csv', header = T)
head(dat)
summary(dat$ev.clearDeath)
unique(dat$ev.clearDeath)
dat.mono <- subset(dat, subset = r.arm.long == 'Ampho mono')
idm(dat)
dim(dat)
unique(dat$r.arm.long)
dat <- subset(dat, subset = r.arm.long != 'Ampho plus fluconazole')
dim(dat)
dat.mono <- subset(dat, subset = r.arm.long == 'Ampho mono')
dat.comb <- subset(dat, subset = r.arm.long != 'Ampho mono')
dim(dat.mono)
dim(dat.comb)
eed <- 21
set.seed(seed=seed)
J <- 3 # number of competing risks (CRs)
n.dat <- 3e2 # size of data set
marprobs=c(.32, .28, .4) # marginal probabilities i.e. probs of eventually having each of the events
# parameter vectors for each competing risk,
# for each vector the last 2 elements are mu and sigma,
# the other elements are the spherical coordinates of the resp. snp-polynomial
par.list = list(c(-.1, .1),
c(pi/9, -.5, .5),
c(pi/9, pi, -.4, .5))
# SNP- or error base distribution i.e.
# dist of Z in log(T) = mu + sig * Z for stdnorm case or
# dist of exp(Z) for exp case
errdists=c("snp.stdnorm", "snp.exp", "snp.stdnorm")
# initialize the vector of event status and time,
# where event status is generate according to the pre-specified marginal probabilities
dat.evstat <- sample(1:J, size=n.dat, replace=T, prob=marprobs)
dat.tte    <- rep(NA, n.dat)
for(j in 1:J) { # loop through each CR
if(errdists[j]=="snp.stdnorm") { # if the base density is that of a stdnorm
if(length(par.list[[j]])==2) { # check if the resp. snp-polynomial is degenerate or not i.e. if
tmp.phi <- NULL              # the resp. spherical coordinates are not NULL
} else {
tmp.phi <- head(par.list[[j]], -2)
}
# generate time to event type j for those destined to have this event
dat.tte[dat.evstat==j] <- simttesnp(n   = length(dat.tte[dat.evstat==j]),
mu  = tail(par.list[[j]],2)[1],
sig = tail(par.list[[j]],2)[2],
phi = tmp.phi,
base.dens="stdnorm")
} else if(errdists[j]=="snp.exp") { # if the base density is that of a stdexp
if(length(par.list[[j]])==2) {
tmp.phi <- NULL
} else {
tmp.phi <- head(par.list[[j]], -2)
}
dat.tte[dat.evstat==j] <- simttesnp(n   = length(dat.tte[dat.evstat==j]),
mu  = tail(par.list[[j]],2)[1],
sig = tail(par.list[[j]],2)[2],
phi = tmp.phi,
base.dens="exp")
}
} # end of for(j in 1:J)
t_m  <- 1.94 # admin. censoring at prefixed time point
rate <- 0.42 # non-admin. independent right censoring following exp dist.
# generate right-censored only data --------------------------------------------------------
dat.rct                        <- pmin(rexp(n=n.dat, rate=rate), t_m)
dat.evstat[dat.tte >= dat.rct] <- 0
dat.tte[dat.evstat==0]         <- dat.rct[dat.evstat==0]
# final right-censored only data set with irrelevant covariates added
dat.rc <- data.frame(tte = dat.tte, evstat = dat.evstat,
x1 = rnorm(length(dat.tte)),
x2 = rexp(length(dat.tte)))
# generate interval censored data --------------------------------------------------------
nints <- 10 # number of intervals
ints  <- seq(from=0, to=t_m, length.out = nints + 1) # set the intervals
# individual-level intervals
ind.ints <- matrix(ints, nrow=1)[rep(1, length(dat.tte)),]
# add some random noise to reflect random visit windows
Noise.mat<- matrix(rnorm(n=(nints-1)*length(dat.tte), mean=0, sd=ints[2]/5), nrow=length(dat.tte))
ind.ints[, 2:(ncol(ind.ints)-1)] <- ind.ints[, 2:(ncol(ind.ints)-1)] + Noise.mat
ind.ints <- t(apply(ind.ints, MARGIN=1, FUN=sort))
L <- R <- rep(NA, length(dat.tte))
R[dat.evstat==0] <- Inf
L[dat.evstat==0] <- dat.tte[dat.evstat==0]
for(r in 1:nrow(ind.ints)) {
if(dat.evstat[r]!=0) {
R[r] <- ind.ints[r,][findInterval(dat.tte[r], ind.ints[r,])+1]
L[r] <- ind.ints[r,][findInterval(dat.tte[r], ind.ints[r,])]
} # end ofif(dat.evstat[r]!=0)
} # end of for(r in nrow(ind.ints))
# final interval ensored data set with irrelevant covariates added
# of note, a final column specifying late entry time or left truncation must be given!
dat.ic <- data.frame(L = L, R = R, evstat = dat.evstat, LT=rep(0, n.dat),
x1= rnorm(length(dat.tte)),
x2= rexp(length(dat.tte)))
head(dat.ic)
criterion <- "HQCn" # info criterion used in the greedy algorithm to choose the best model
# supported values are: AIC, HQCn, HQCd, BICn and BICd
check.hess <- FALSE # if T (default) estimated model whose hessian matrix has negative eigenvalues will be removed.
parallelism <- TRUE # if to use parallel package
ncores      <- 4    # number of cores used for prallelism if any
kms <- c(3, 3, 3) # A vector having the maximum polynomial degrees in fitting the snp distribution of P(T|D)
anal.grad <- snpcr.grad.loglik # function implementing the analytical gradient for the loglikelihood,.
# This has already bee
formula.ic <- Hist(list(L,R), EvStat, cens.code=0) ~ 1
snpm.mod.ic <- snp.crreg(formula = update(formula.ic, ~ . + x1 + x2), data = dat.ic,
base.dens = c("stdnorm", "exp", 'stdnorm'), kms = kms,
criterion = criterion, anal.grad = anal.grad, check.hess = check.hess,
parallelism=parallelism, ncores=ncores,
control=list(maxiter=100))
ee
formula.ic <- Hist(list(L,R), evstat, cens.code=0) ~ 1
snpm.mod.ic <- snp.crreg(formula = update(formula.ic, ~ . + x1 + x2), data = dat.ic,
base.dens = c("stdnorm", "exp", 'stdnorm'), kms = kms,
criterion = criterion, anal.grad = anal.grad, check.hess = check.hess,
parallelism=parallelism, ncores=ncores,
control=list(maxiter=100))
snpm.mod.ic
seed <- 21
set.seed(seed=seed)
J <- 3 # number of competing risks (CRs)
n.dat <- 3e2 # size of data set
marprobs=c(.32, .28, .4) # marginal probabilities i.e. probs of eventually having each of the events
# parameter vectors for each competing risk,
# for each vector the last 2 elements are mu and sigma,
# the other elements are the spherical coordinates of the resp. snp-polynomial
par.list = list(c(-.1, .1),
c(pi/9, -.5, .5),
c(pi/9, pi, -.4, .5))
# SNP- or error base distribution i.e.
# dist of Z in log(T) = mu + sig * Z for stdnorm case or
# dist of exp(Z) for exp case
errdists=c("snp.stdnorm", "snp.exp", "snp.stdnorm")
# initialize the vector of event status and time,
# where event status is generate according to the pre-specified marginal probabilities
dat.evstat <- sample(1:J, size=n.dat, replace=T, prob=marprobs)
dat.tte    <- rep(NA, n.dat)
for(j in 1:J) { # loop through each CR
if(errdists[j]=="snp.stdnorm") { # if the base density is that of a stdnorm
if(length(par.list[[j]])==2) { # check if the resp. snp-polynomial is degenerate or not i.e. if
tmp.phi <- NULL              # the resp. spherical coordinates are not NULL
} else {
tmp.phi <- head(par.list[[j]], -2)
}
# generate time to event type j for those destined to have this event
dat.tte[dat.evstat==j] <- simttesnp(n   = length(dat.tte[dat.evstat==j]),
mu  = tail(par.list[[j]],2)[1],
sig = tail(par.list[[j]],2)[2],
phi = tmp.phi,
base.dens="stdnorm")
} else if(errdists[j]=="snp.exp") { # if the base density is that of a stdexp
if(length(par.list[[j]])==2) {
tmp.phi <- NULL
} else {
tmp.phi <- head(par.list[[j]], -2)
}
dat.tte[dat.evstat==j] <- simttesnp(n   = length(dat.tte[dat.evstat==j]),
mu  = tail(par.list[[j]],2)[1],
sig = tail(par.list[[j]],2)[2],
phi = tmp.phi,
base.dens="exp")
}
} # end of for(j in 1:J)
t_m  <- 1.94 # admin. censoring at prefixed time point
rate <- 0.42 # non-admin. independent right censoring following exp dist.
# generate right-censored only data --------------------------------------------------------
dat.rct                        <- pmin(rexp(n=n.dat, rate=rate), t_m)
dat.evstat[dat.tte >= dat.rct] <- 0
dat.tte[dat.evstat==0]         <- dat.rct[dat.evstat==0]
# final right-censored only data set with irrelevant covariates added
dat.rc <- data.frame(tte = dat.tte, evstat = dat.evstat,
x1 = rnorm(length(dat.tte)),
x2 = rexp(length(dat.tte)))
# generate interval censored data --------------------------------------------------------
nints <- 10 # number of intervals
ints  <- seq(from=0, to=t_m, length.out = nints + 1) # set the intervals
# individual-level intervals
ind.ints <- matrix(ints, nrow=1)[rep(1, length(dat.tte)),]
# add some random noise to reflect random visit windows
Noise.mat<- matrix(rnorm(n=(nints-1)*length(dat.tte), mean=0, sd=ints[2]/5), nrow=length(dat.tte))
ind.ints[, 2:(ncol(ind.ints)-1)] <- ind.ints[, 2:(ncol(ind.ints)-1)] + Noise.mat
ind.ints <- t(apply(ind.ints, MARGIN=1, FUN=sort))
L <- R <- rep(NA, length(dat.tte))
R[dat.evstat==0] <- Inf
L[dat.evstat==0] <- dat.tte[dat.evstat==0]
for(r in 1:nrow(ind.ints)) {
if(dat.evstat[r]!=0) {
R[r] <- ind.ints[r,][findInterval(dat.tte[r], ind.ints[r,])+1]
L[r] <- ind.ints[r,][findInterval(dat.tte[r], ind.ints[r,])]
} # end ofif(dat.evstat[r]!=0)
} # end of for(r in nrow(ind.ints))
# final interval ensored data set with irrelevant covariates added
# of note, a final column specifying late entry time or left truncation must be given!
dat.ic <- data.frame(L = L, R = R, evstat = dat.evstat, LT=rep(0, n.dat),
x1= rnorm(length(dat.tte)),
x2= rexp(length(dat.tte)))
summary(dat.ic$L)
dat.ic$L[dat.ic$L==0] <- dat.ic$L[dat.ic$L==0] + .001 # otherwise optimization crashes!
formula.ic <- Hist(list(L,R), evstat, cens.code=0) ~ 1
snpm.mod.ic <- snp.crreg(formula = update(formula.ic, ~ . + x1 + x2), data = dat.ic,
base.dens = c("stdnorm", "exp", 'stdnorm'), kms = kms,
criterion = criterion, anal.grad = anal.grad, check.hess = check.hess,
parallelism=parallelism, ncores=ncores,
control=list(maxiter=100))
snpm.mod.ic
dat <- read.csv('cleardeath.csv', header = T)
dat <- subset(dat, subset = r.arm.long != 'Ampho plus fluconazole') # not use this arm
dim(dat) # 175
# Pure CIF estimation for each treatment arm
dat.mono <- subset(dat, subset = r.arm.long == 'Ampho mono') # mono  therapy
dat.comb <- subset(dat, subset = r.arm.long != 'Ampho mono') # combo therapy
formula.app <- Hist(list(tt.clearDeath.lower, tt.clearDeath.upper), ev.clearDeath, cens.code=0) ~ 1
snp.mod.mono <- snp.crreg(formula   = formula.app, data = dat.mono,
base.dens = c("stdnorm", "stdnorm"), kms = c(3, 3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
snp.mod.mono <- snp.crreg(formula   = formula.app, data = dat.mono,
base.dens = c("stdnorm", "stdnorm"), kms = c(3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
snp.mod.comb <- snp.crreg(formula   = formula.app, data = dat.comb,
base.dens = c("stdnorm", "stdnorm"), kms = c(3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
snp.mod.mono.e <- snp.crreg(formula   = formula.app, data = dat.mono,
base.dens = c("exp", "exp"), kms = c(3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
snp.mod.comb.e <- snp.crreg(formula   = formula.app, data = dat.comb,
base.dens = c("exp", "exp"), kms = c(3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
snp.mod.mono$base.dens
snp.mod.mono$final.outs
snp.mod.comb$final.outs
best.snp.mono <- tail(snp.mod.mono$final.outs, 1)
> best.snp.mono
best.snp.mono
best.snp.mono[[1]]
best.snp.mono <- tail(snp.mod.mono$final.outs, 1)[[1]]
best.snp.mono
head(dat)
summary(dat$tt.clearDeath.lower)
summary(dat$tt.clearDeath.upper)
times <- seq(0, 28, length.out = 100)
head(snp.cif)
head(best.snp.mono$P)
times <- seq(0, 28, length.out = 100)
best.snp.mono <- tail(snp.mod.mono$final.outs, 1)[[1]]
snp.cif(tt = times, theta = c(best.snp.mono$phis, best.snp.mono$mu.sigs),
base.dens = snp.mod.mono$base.dens, bet = NULL, y = NULL, P = best.snp.mono$P[1,1])
ee
c(best.snp.mono$phis, best.snp.mono$mu.sigs)
best.snp.mono$phis
snp.cif(tt = times, theta = c(best.snp.mono$phis[[1]], best.snp.mono$mu.sigs[1,]),
base.dens = snp.mod.mono$base.dens, bet = NULL, y = NULL, P = best.snp.mono$P[1,1])
head(dat)
cif.mono.death <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[2]], best.snp.mono$mu.sigs[2,]),
base.dens = snp.mod.mono$base.dens, bet = NULL, y = NULL, P = best.snp.mono$P[1,2])
cif.mono.clear <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[1]], best.snp.mono$mu.sigs[1,]),
base.dens = snp.mod.mono$base.dens, bet = NULL, y = NULL, P = best.snp.mono$P[1,1])
cif.mono.death <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[2]], best.snp.mono$mu.sigs[2,]),
base.dens = snp.mod.mono$base.dens[2], bet = NULL, y = NULL, P = best.snp.mono$P[1,2])
cif.mono.clear <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[1]], best.snp.mono$mu.sigs[1,]),
base.dens = snp.mod.mono$base.dens[1], bet = NULL, y = NULL, P = best.snp.mono$P[1,1])
cif.mono.clear
cif.comb.clear <- snp.cif(tt = times, theta = c(best.snp.comb$phis[[1]], best.snp.comb$mu.sigs[1,]),
base.dens = snp.mod.comb$base.dens[1], bet = NULL, y = NULL, P = best.snp.comb$P[1,1])
ee
best.snp.comb <- tail(snp.mod.comb$final.outs, 1)[[1]]
cif.comb.clear <- snp.cif(tt = times, theta = c(best.snp.comb$phis[[1]], best.snp.comb$mu.sigs[1,]),
base.dens = snp.mod.comb$base.dens[1], bet = NULL, y = NULL, P = best.snp.comb$P[1,1])
cif.comb.death <- snp.cif(tt = times, theta = c(best.snp.comb$phis[[2]], best.snp.comb$mu.sigs[2,]),
base.dens = snp.mod.comb$base.dens[2], bet = NULL, y = NULL, P = best.snp.comb$P[1,2])
?par
plot(times, cif.mono.clear, type='l', bty= 'l')
plot(times, cif.mono.clear, type='l', bty= 'c')
plot(times, cif.mono.clear, type='l', bty= 'u')
plot(times, cif.mono.clear, type='l', bty= '7')
plot(times, cif.mono.clear, type='l', bty= ']')
plot(times, cif.mono.clear, type='l', bty= 'n')
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability')
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability', xlim=c(0,28))
snp.mod.mono <- snp.crreg(formula   = formula.app, data = dat.mono,
base.dens = c("exp", "exp"), kms = c(3, 3),
criterion = 'HQCn', anal.grad = anal.grad, check.hess = F,
parallelism=T, ncores=4,
control=list(maxiter=100))
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability', xlim=c(0,28))
best.snp.mono <- tail(snp.mod.mono$final.outs, 1)[[1]]
best.snp.comb <- tail(snp.mod.comb$final.outs, 1)[[1]]
cif.mono.clear <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[1]], best.snp.mono$mu.sigs[1,]),
base.dens = snp.mod.mono$base.dens[1], bet = NULL, y = NULL, P = best.snp.mono$P[1,1])
cif.comb.clear <- snp.cif(tt = times, theta = c(best.snp.comb$phis[[1]], best.snp.comb$mu.sigs[1,]),
base.dens = snp.mod.comb$base.dens[1], bet = NULL, y = NULL, P = best.snp.comb$P[1,1])
# event type 2 is prior death
cif.mono.death <- snp.cif(tt = times, theta = c(best.snp.mono$phis[[2]], best.snp.mono$mu.sigs[2,]),
base.dens = snp.mod.mono$base.dens[2], bet = NULL, y = NULL, P = best.snp.mono$P[1,2])
cif.comb.death <- snp.cif(tt = times, theta = c(best.snp.comb$phis[[2]], best.snp.comb$mu.sigs[2,]),
base.dens = snp.mod.comb$base.dens[2], bet = NULL, y = NULL, P = best.snp.comb$P[1,2])
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability', xlim=c(0,28))
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability',
xlim=c(0,28), lwd=2)
lines(times, cif.comb.clear, col=gray(.8))
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability',
xlim=c(0,28), ylim=c(0,1), lwd=2)
lines(times, cif.comb.clear, col=gray(.8))
lines(times, cif.comb.clear, col=gray(.8), lwd=2)
lines(times, 1-cif.mono.death, lwd=2)
lines(times, 1-cif.comb.death, col=gray(.8), lwd=2)
text(x=16, y=0.2, labels = 'Fungal Clearance')
text(x=16, y=0.2, labels = 'Fungal Clearance', cex = 2)
text(x=20, y=0.2, labels = 'Fungal Clearance', cex = 2)
text(x=20, y=0.9, labels = 'Prior Death', cex = 2)
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability',
xlim=c(0,28), ylim=c(0,1), lwd=2)
lines(times, cif.comb.clear, col=gray(.8), lwd=2)
lines(times, 1-cif.mono.death, lwd=2)
lines(times, 1-cif.comb.death, col=gray(.8), lwd=2)
text(x=20, y=0.2, labels = 'Fungal Clearance', cex = 2)
text(x=20, y=0.9, labels = 'Prior Death', cex = 2)
legend(x = 0, y=.5, lwd=2, col = c('black', gray(0.8)), legend = c('Ampho mono', 'Ampho + flucytosine'))
?legend
x11()
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability',
xlim=c(0,28), ylim=c(0,1), lwd=2)
lines(times, cif.comb.clear, col=gray(.8), lwd=2)
lines(times, 1-cif.mono.death, lwd=2)
lines(times, 1-cif.comb.death, col=gray(.8), lwd=2)
text(x=20, y=0.2, labels = 'Fungal Clearance', cex = 2)
text(x=20, y=0.9, labels = 'Prior Death', cex = 2)
legend(x = 0, y=.7, lwd=2, col = c('black', gray(0.8)), legend = c('Ampho mono', 'Ampho + flucytosine'), bty = 'n')
x11()
plot(times, cif.mono.clear, type='l', bty= 'n', xlab='Days since randomization', ylab = 'Probability',
xlim=c(0,28), ylim=c(0,1), lwd=2, main='CIF of Fungale  Clearance and 1 - CIF of Prior Death')
lines(times, cif.comb.clear, col=gray(.8), lwd=2)
lines(times, 1-cif.mono.death, lwd=2)
lines(times, 1-cif.comb.death, col=gray(.8), lwd=2)
text(x=20, y=0.2, labels = 'Fungal Clearance', cex = 2)
text(x=20, y=0.9, labels = 'Prior Death', cex = 2)
legend(x = 0, y=.7, lwd=2, col = c('black', gray(0.8)), legend = c('Ampho mono', 'Ampho + flucytosine'), bty = 'n')
getwd
getwd
getwd()
